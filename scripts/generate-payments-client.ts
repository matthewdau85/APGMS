import { mkdirSync, writeFileSync } from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { paymentsOpenApiDocument } from "../src/api/payments";

type Schema = any;

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const outDir = path.resolve(__dirname, "../src/api/generated");
mkdirSync(outDir, { recursive: true });

const schemaFile = path.join(outDir, "payments.openapi.json");
writeFileSync(schemaFile, JSON.stringify(paymentsOpenApiDocument, null, 2));

const schemas = paymentsOpenApiDocument.components?.schemas ?? {};

function resolveRef(ref: string): string {
  return ref.split("/").pop() ?? ref;
}

function schemaType(schema: Schema): string {
  if (!schema) return "unknown";
  if (schema.$ref) return resolveRef(schema.$ref);
  if (schema.type === "integer" || schema.type === "number") return "number";
  if (schema.type === "string") {
    if (schema.enum) return schema.enum.map((v: string) => JSON.stringify(v)).join(" | ");
    return "string";
  }
  if (schema.type === "boolean") return "boolean";
  if (schema.type === "array") return `${schemaType(schema.items)}[]`;
  if (schema.type === "object") return "Record<string, unknown>";
  if (schema.enum) return schema.enum.map((v: string) => JSON.stringify(v)).join(" | ");
  return "unknown";
}

function generateType(name: string, schema: Schema): string {
  if (schema.enum) {
    return `export type ${name} = ${schema.enum.map((v: string) => JSON.stringify(v)).join(" | ")};`;
  }
  if (schema.type === "object") {
    const props = schema.properties ?? {};
    const required = new Set<string>(schema.required ?? []);
    const lines = Object.entries(props).map(([prop, propSchema]: [string, Schema]) => {
      const baseType = schemaType(propSchema);
      const type = propSchema.nullable ? `${baseType} | null` : baseType;
      const optional = required.has(prop) ? "" : "?";
      return `  ${prop}${optional}: ${type};`;
    });
    return `export interface ${name} {\n${lines.join("\n")}\n}`;
  }
  return `export type ${name} = ${schemaType(schema)};`;
}

const typeChunks: string[] = [];
for (const [name, schema] of Object.entries<Schema>(schemas)) {
  typeChunks.push(generateType(name, schema));
}

const typesSource = typeChunks.join("\n\n");

const clientSource = `/* eslint-disable */
// Generated by scripts/generate-payments-client.ts
${typesSource}

export interface PaymentsClientOptions {
  baseUrl?: string;
  fetchImpl?: typeof fetch;
  defaultHeaders?: Record<string, string>;
}

function resolveFetch(fetchImpl?: typeof fetch): typeof fetch {
  if (fetchImpl) return fetchImpl;
  if (typeof fetch !== "undefined") return fetch.bind(globalThis);
  throw new Error("fetch implementation required");
}

async function handleResponse<T>(res: Response): Promise<T> {
  if (!res.ok) {
    let detail: any = null;
    try {
      detail = await res.json();
    } catch {
      try {
        detail = await res.text();
      } catch {
        detail = null;
      }
    }
    const message =
      typeof detail === "object" && detail !== null
        ? detail.error || detail.message || JSON.stringify(detail)
        : String(detail || "HTTP " + res.status);
    throw new Error(message);
  }
  return (await res.json()) as T;
}

export function createPaymentsClient(options: PaymentsClientOptions = {}) {
  const baseUrl = options.baseUrl ?? "/api";
  const fetchImpl = resolveFetch(options.fetchImpl);
  const defaultHeaders = { "content-type": "application/json", ...(options.defaultHeaders ?? {}) };

  return {
    async pay(body: PayRequest): Promise<PaymentResponse> {
      const res = await fetchImpl(baseUrl + "/payments/pay", {
        method: "POST",
        headers: defaultHeaders,
        body: JSON.stringify(body),
      });
      return handleResponse<PaymentResponse>(res);
    },
    async getPayment(id: string): Promise<PaymentResponse> {
      const res = await fetchImpl(baseUrl + "/payments/" + encodeURIComponent(id), {
        method: "GET",
        headers: options.defaultHeaders ?? {},
      });
      return handleResponse<PaymentResponse>(res);
    },
    async refund(body: PayRequest): Promise<Response> {
      return fetchImpl(baseUrl + "/payments/refund", {
        method: "POST",
        headers: defaultHeaders,
        body: JSON.stringify(body),
      });
    },
  };
}
`;

const apiFile = path.join(outDir, "api.ts");
writeFileSync(apiFile, clientSource);
