export type SafeParseSuccess<T> = { success: true; data: T };
export type SafeParseFailure = { success: false; error: ZodError };
export type SafeParseReturnType<T> = SafeParseSuccess<T> | SafeParseFailure;

export interface ZodType<T> {
  safeParse(data: unknown): SafeParseReturnType<T>;
  parse(data: unknown): T;
  optional(): ZodType<T | undefined>;
  nullish(): ZodType<T | null | undefined>;
  describe(description: string): this;
}

export interface ZodString extends ZodType<string> {
  trim(): this;
  min(length: number): this;
  uuid(): this;
  datetime(): this;
}

export interface ZodNumber extends ZodType<number> {
  int(): this;
  positive(): this;
}

export interface ZodEnum<T extends readonly [string, ...string[]]> extends ZodType<T[number]> {}
export interface ZodArray<T> extends ZodType<T[]> {}

export type ZodRawShape = { [key: string]: ZodType<any> };
export interface ZodObject<T extends ZodRawShape> extends ZodType<{ [K in keyof T]: T[K] extends ZodType<infer O> ? O : never }> {}

export declare class ZodError extends Error {
  issues: { path: (string | number)[]; message: string }[];
  flatten(): { formErrors: string[]; fieldErrors: Record<string, string[]> };
}

export declare const z: {
  string(): ZodString;
  number(): ZodNumber;
  enum<T extends readonly [string, ...string[]]>(values: T): ZodEnum<T>;
  array<T>(schema: ZodType<T>): ZodArray<T>;
  object<T extends ZodRawShape>(shape: T): ZodObject<T>;
  any(): ZodType<any>;
};

export type Infer<T extends ZodType<any>> = T extends ZodType<infer Output> ? Output : never;
export type TypeOf<T extends ZodType<any>> = Infer<T>;
export type ZodTypeAny = ZodType<any>;

export declare namespace z {
  type infer<T extends ZodTypeAny> = Infer<T>;
  type TypeOf<T extends ZodTypeAny> = Infer<T>;
}
