class ZodError extends Error {
  constructor(issues) {
    super("Validation failed");
    this.name = "ZodError";
    this.issues = issues.map((issue) => ({
      path: Array.isArray(issue.path) ? issue.path : [],
      message: issue.message || "Invalid value",
    }));
  }

  flatten() {
    const fieldErrors = {};
    for (const issue of this.issues) {
      const key = issue.path.length ? issue.path.join(".") : "";
      if (!fieldErrors[key]) fieldErrors[key] = [];
      fieldErrors[key].push(issue.message);
    }
    return { formErrors: [], fieldErrors };
  }
}

class BaseSchema {
  constructor() {
    this._description = undefined;
  }

  describe(desc) {
    this._description = desc;
    return this;
  }

  optional() {
    return new OptionalSchema(this, false);
  }

  nullish() {
    return new OptionalSchema(this, true);
  }

  _run(_value, _path) {
    throw new Error("Not implemented");
  }

  parse(value) {
    const result = this.safeParse(value);
    if (!result.success) throw result.error;
    return result.data;
  }

  safeParse(value) {
    try {
      const data = this._run(value, []);
      return { success: true, data };
    } catch (err) {
      if (err instanceof ZodError) {
        return { success: false, error: err };
      }
      throw err;
    }
  }
}

class OptionalSchema extends BaseSchema {
  constructor(inner, allowNull) {
    super();
    this.inner = inner;
    this.allowNull = allowNull;
  }

  _run(value, path) {
    if (value === undefined) return undefined;
    if (value === null && this.allowNull) return null;
    return this.inner._run(value, path);
  }
}

class AnySchema extends BaseSchema {
  _run(value) {
    return value;
  }
}

class StringSchema extends BaseSchema {
  constructor() {
    super();
    this._checks = [];
    this._transformers = [];
  }

  trim() {
    this._transformers.push((val) => val.trim());
    return this;
  }

  min(len) {
    this._checks.push((val, path) => {
      if (val.length < len) {
        throw new ZodError([{ path, message: `String must contain at least ${len} character(s)` }]);
      }
    });
    return this;
  }

  uuid() {
    const regex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    this._checks.push((val, path) => {
      if (!regex.test(val)) {
        throw new ZodError([{ path, message: "Invalid uuid" }]);
      }
    });
    return this;
  }

  datetime() {
    this._checks.push((val, path) => {
      const date = new Date(val);
      if (Number.isNaN(date.getTime())) {
        throw new ZodError([{ path, message: "Invalid datetime" }]);
      }
    });
    return this;
  }

  _run(value, path) {
    if (typeof value !== "string") {
      throw new ZodError([{ path, message: "Expected string" }]);
    }
    let current = value;
    for (const transform of this._transformers) {
      current = transform(current);
    }
    for (const check of this._checks) {
      check(current, path);
    }
    return current;
  }
}

class NumberSchema extends BaseSchema {
  constructor() {
    super();
    this._checks = [];
  }

  int() {
    this._checks.push((val, path) => {
      if (!Number.isInteger(val)) {
        throw new ZodError([{ path, message: "Expected integer" }]);
      }
    });
    return this;
  }

  positive() {
    this._checks.push((val, path) => {
      if (!(val > 0)) {
        throw new ZodError([{ path, message: "Expected positive number" }]);
      }
    });
    return this;
  }

  _run(value, path) {
    if (typeof value !== "number" || Number.isNaN(value)) {
      throw new ZodError([{ path, message: "Expected number" }]);
    }
    for (const check of this._checks) {
      check(value, path);
    }
    return value;
  }
}

class EnumSchema extends BaseSchema {
  constructor(values) {
    super();
    this.values = values;
  }

  _run(value, path) {
    if (typeof value !== "string" || !this.values.includes(value)) {
      throw new ZodError([{ path, message: `Expected one of: ${this.values.join(", ")}` }]);
    }
    return value;
  }
}

class ArraySchema extends BaseSchema {
  constructor(inner) {
    super();
    this.inner = inner;
  }

  _run(value, path) {
    if (!Array.isArray(value)) {
      throw new ZodError([{ path, message: "Expected array" }]);
    }
    const result = [];
    const issues = [];
    value.forEach((item, index) => {
      try {
        const parsed = this.inner._run(item, [...path, index]);
        result.push(parsed);
      } catch (err) {
        if (err instanceof ZodError) {
          issues.push(...err.issues);
        } else {
          throw err;
        }
      }
    });
    if (issues.length) throw new ZodError(issues);
    return result;
  }
}

class ObjectSchema extends BaseSchema {
  constructor(shape) {
    super();
    this.shape = shape;
  }

  _run(value, path) {
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new ZodError([{ path, message: "Expected object" }]);
    }
    const result = {};
    const issues = [];
    for (const key of Object.keys(this.shape)) {
      const schema = this.shape[key];
      try {
        result[key] = schema._run(value[key], [...path, key]);
      } catch (err) {
        if (err instanceof ZodError) {
          issues.push(...err.issues);
        } else {
          throw err;
        }
      }
    }
    if (issues.length) throw new ZodError(issues);
    return result;
  }
}

const z = {
  string: () => new StringSchema(),
  number: () => new NumberSchema(),
  enum: (values) => new EnumSchema(values),
  array: (schema) => new ArraySchema(schema),
  object: (shape) => new ObjectSchema(shape),
  any: () => new AnySchema(),
};

module.exports = { z, ZodError };
