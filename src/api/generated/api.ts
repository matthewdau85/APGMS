/* eslint-disable */
// Generated by scripts/generate-payments-client.ts
export interface PayRequest {
  abn: string;
  period: string;
  amountCents: number;
  idempotencyKey?: string;
}

export type PaymentStatus = "blocked" | "succeeded" | "failed";

export interface LedgerEntry {
  id: string;
  direction: "DEBIT" | "CREDIT";
  amountCents: number;
  note?: string;
  createdAt: string;
}

export interface PaymentResponse {
  id: string;
  abn: string;
  period: string;
  amountCents: number;
  status: PaymentStatus;
  traceId: string;
  idempotencyKey?: string | null;
  createdAt: string;
  ledgerEntries: LedgerEntry[];
}

export interface PaymentsClientOptions {
  baseUrl?: string;
  fetchImpl?: typeof fetch;
  defaultHeaders?: Record<string, string>;
}

function resolveFetch(fetchImpl?: typeof fetch): typeof fetch {
  if (fetchImpl) return fetchImpl;
  if (typeof fetch !== "undefined") return fetch.bind(globalThis);
  throw new Error("fetch implementation required");
}

async function handleResponse<T>(res: Response): Promise<T> {
  if (!res.ok) {
    let detail: any = null;
    try {
      detail = await res.json();
    } catch {
      try {
        detail = await res.text();
      } catch {
        detail = null;
      }
    }
    const message =
      typeof detail === "object" && detail !== null
        ? detail.error || detail.message || JSON.stringify(detail)
        : String(detail || "HTTP " + res.status);
    throw new Error(message);
  }
  return (await res.json()) as T;
}

export function createPaymentsClient(options: PaymentsClientOptions = {}) {
  const baseUrl = options.baseUrl ?? "/api";
  const fetchImpl = resolveFetch(options.fetchImpl);
  const defaultHeaders = { "content-type": "application/json", ...(options.defaultHeaders ?? {}) };

  return {
    async pay(body: PayRequest): Promise<PaymentResponse> {
      const res = await fetchImpl(baseUrl + "/payments/pay", {
        method: "POST",
        headers: defaultHeaders,
        body: JSON.stringify(body),
      });
      return handleResponse<PaymentResponse>(res);
    },
    async getPayment(id: string): Promise<PaymentResponse> {
      const res = await fetchImpl(baseUrl + "/payments/" + encodeURIComponent(id), {
        method: "GET",
        headers: options.defaultHeaders ?? {},
      });
      return handleResponse<PaymentResponse>(res);
    },
    async refund(body: PayRequest): Promise<Response> {
      return fetchImpl(baseUrl + "/payments/refund", {
        method: "POST",
        headers: defaultHeaders,
        body: JSON.stringify(body),
      });
    },
  };
}
