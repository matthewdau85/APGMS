# File: chunk_000968.txt (part 1 of 1)
```
it to validate it. So, you can see in between here and storing of this information, how easy it could be to steal and reuse that information to take over an account. This is why we have such rampant account takeover. The burden is on our users to recognize if and when they're being tricked into giving away their sign-in credentials. Now with passkeys, there's no shared knowledge. There's nothing that the user can actually give away. What the user has is a private key, a cryptographic key. It's unique to the service. And the service has a corresponding public key, which you can do nothing with if you were to get into that server, for example. So, when the user approves that sign in, the device and the service communicate with each other to validate that they each have the right key and then the user is signed in. That's just transparent to the user. You don't send any sign-in information or biometric information over to a service provider that can be stolen and used to take over an account. So, it's really not something you can give away. But what's really important, too, is that your passkey can only be used to sign into the correct website with the correct URL. So even if a user gets tricked and goes to a spoofed site, which happens all the time through phishing attacks, their device will actually tell them, no, you cannot sign in here. And so, there's no burden on the user to have to identify a phishing attack. And that's really the beauty of passkeys is that it is phishing resistant and super easy to use. Alicia Malone: Thank you so much for sharing that. Andrew, I know that the Council has quite a bit of guidance and requirements when it comes to passwords, but what about passkeys? Does PCI SSC have a stance on passkey usage? Andrew Jamieson: We do. So, we have a number of requirements when it comes to access to things. And primarily it comes down to Requirements 8.4.1, 8.4.2, and 8.4.3 in PCI DSS specifically we're talking about here. 8.4.1 is about what we call non-console access into the cardholder data environment for people who have administrative access. 8.4.2 is non-console access for everybody, not admin, but everybody else. And 8.4.3 is access from outside the entity's network into the entity's network. And with those requirements, when it comes to 8.4.2, which is all non-console access - so non-admin access, you're already in your network and you're going from that point in the network into the cardholder data environment - you can use passkeys or what we call phishing-resistant authentication in that context, to get into - to authenticate yourself - to get into that particular area of the network into the CDE. Now, if you're not using phishing-resistant authentication, we require you to use MFA for that, but in the context of 8.4.2 non-admin access you can use phishing-resistant authentication in the place of MFA. For the other requirements, 8.4.1 and 8.4.3, we recommend the use of phishing-resistant authentication, for all the reasons that Megan was talking about. It's a fantastic technology. It prevents people from having their secrets stolen in terms of password archives or those things being brute forced and stuffing attacks, all the stuff that goes on, because you don't have a secret stored in the backend system you're authenticating to. But when it comes to 8.4.1, when it's, we're talking about administrative access, when it comes to 8.4.3, when we're talking about remote access into the network, then in those contexts, we require that although you can use, and we do recommend the use of phishing-resistant authentication, you need to have another factor. And Megan did mention that often you will have another factor in the context of these kinds of systems. You'll be using a password or a biometric or something like that. And so that might work in to use that along with the passkey or the phishing resistant auth to act as multi-factor authentication. However, there are some instances where you would not, and we're actually releasing some FAQs to further provide some information on these systems. Alicia Malone: Now, there are two types of passkeys, a synced passkey and a device-bound passkey. So Megan, can you explain the difference for our listeners and what we need to know about each one of these? Megan Shamas: Yes, and I think that's important in the context of what Andrew was just speaking about in terms of MFA and phishing-resistant authentication and, you know, it's a triangle and a square and it's one thing, and the same. And there are cases where, you know, requirements might necessitate multiple factors. And then there are cases where phishing resistance is just needed regardless of factors. And there still could be factors involved, but the phishing resistance is the key part of that. And I think sometimes, to answer your question, terminology sometimes can be a little bit, can be tricky, right, when it comes to these kinds of things. But it's pretty simple actually. A synced passkey is a passkey that you can access across devices through a secure credential manager, like you mentioned before, there's password managers out there. That’s what historically we would call them, but it could be like the iCloud keychain, Google passwords, One Password, Dash
```

