from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import JSONResponse, PlainTextResponse
from jsonschema import Draft202012Validator
from hashlib import sha256
import os, time, orjson
from prometheus_client import Counter, generate_latest
from nats.aio.client import Client as NATS

app = FastAPI(title="APGMS Event Normalizer", version="0.1.0")
NATS_URL = os.environ.get("NATS_URL", "")
SERVICE_PORT = int(os.environ.get("SERVICE_PORT", "8001"))
events_seen = Counter("apgms_normalizer_events_total","events received",["type"])
events_pub  = Counter("apgms_normalizer_published_total","events published",["type"])
events_fail = Counter("apgms_normalizer_failed_total","events failed",["stage"])

def _schema_path(name: str) -> str:
    here = os.path.dirname(__file__)
    root = os.path.abspath(os.path.join(here, "..","..","..",".."))
    return os.path.join(root, "libs","schemas","json", f"{name}.v1.json")

def _load_schema(name: str):
    import json
    with open(_schema_path(name),"r",encoding="utf-8") as f:
        return json.load(f)

validators = {
    "payroll": Draft202012Validator(_load_schema("payroll_event")),
    "pos": Draft202012Validator(_load_schema("pos_event")),
    "bank": Draft202012Validator(_load_schema("bank_event")),
}

_nc:NATS|None = None
async def get_nats():
    global _nc
    if NATS_URL and _nc is None:
        _nc = NATS()
        await _nc.connect(servers=[NATS_URL])
    return _nc

@app.get("/healthz", response_class=PlainTextResponse)
async def healthz(): return "ok"

@app.get("/metrics")
async def metrics(): return PlainTextResponse(generate_latest().decode("utf-8"))

@app.post("/ingest")
async def ingest(req: Request):
    try:
        body = await req.json()
    except Exception:
        events_fail.labels(stage="parse").inc()
        raise HTTPException(400,"invalid JSON")
    et = body.get("event_type")
    if et not in validators:
        events_fail.labels(stage="validate").inc()
        raise HTTPException(400, f"unsupported event_type {et}")
    # enrich
    body.setdefault("version","v1")
    body.setdefault("signed_at", time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()))
    body.setdefault("producer_id","dev")
    src_hash = sha256(orjson.dumps(body, option=orjson.OPT_SORT_KEYS)).hexdigest()
    body.setdefault("src_hash", src_hash)
    # validate
    errs = sorted(validators[et].iter_errors(body), key=lambda e: e.path)
    if errs:
        events_fail.labels(stage="validate").inc()
        raise HTTPException(422, str([e.message for e in errs]))
    events_seen.labels(type=et).inc()
    published = False
    try:
        n = await get_nats()
        if n:
            subj = f"apgms.{et}.canonical.v1"
            await n.publish(subj, orjson.dumps(body))
            published = True
            events_pub.labels(type=et).inc()
    except Exception:
        published = False
    return JSONResponse({"ok": True, "published": published, "src_hash": src_hash, "event_type": et})
