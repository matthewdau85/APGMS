"""Rounding helpers for PAYG withholding calculations."""
from __future__ import annotations

from decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN, ROUND_UP, ROUND_DOWN, getcontext
from typing import Literal

RoundMode = Literal["NEAREST", "UP", "DOWN", "HALF_EVEN"]

getcontext().prec = 28


def _to_decimal(value: float | int | str) -> Decimal:
    if isinstance(value, Decimal):
        return value
    return Decimal(str(value))


def round_decimal(value: float | int | Decimal, *, increment: float = 0.01, mode: RoundMode = "NEAREST") -> Decimal:
    """Round ``value`` to ``increment`` using the supplied ``mode``.

    The calculation is performed using :class:`~decimal.Decimal` so that large
    intermediate results such as those generated by annualising weekly earnings
    do not accumulate floating point error. ``increment`` is interpreted as a
    positive quantity expressed in the same unit as ``value`` (typically
    dollars).
    """
    quant = _to_decimal(increment)
    if quant <= 0:
        raise ValueError("increment must be positive")
    dval = _to_decimal(value)
    scaled = dval / quant
    if mode == "NEAREST":
        rounded = scaled.quantize(Decimal("1"), rounding=ROUND_HALF_UP)
    elif mode == "HALF_EVEN":
        rounded = scaled.quantize(Decimal("1"), rounding=ROUND_HALF_EVEN)
    elif mode == "UP":
        rounded = scaled.quantize(Decimal("1"), rounding=ROUND_UP)
    elif mode == "DOWN":
        rounded = scaled.quantize(Decimal("1"), rounding=ROUND_DOWN)
    else:
        raise ValueError(f"Unsupported rounding mode: {mode}")
    return rounded * quant


def round_to_cents(value: float | int | Decimal) -> Decimal:
    """Round to cents using standard half-up rounding."""
    return round_decimal(value, increment=0.01, mode="NEAREST")


def to_float(value: float | int | Decimal) -> float:
    """Convert a :class:`~decimal.Decimal` back to :class:`float`."""
    if isinstance(value, Decimal):
        return float(value)
    return float(value)
