const EventEmitter = require('events');

class CircuitBreaker extends EventEmitter {
  constructor(action, options = {}) {
    if (typeof action !== 'function') {
      throw new TypeError('CircuitBreaker requires a function');
    }
    super();
    this.action = action;
    this.options = Object.assign({
      timeout: 10000,
      errorThresholdPercentage: 50,
      resetTimeout: 30000,
      volumeThreshold: 5,
      name: undefined,
    }, options);
    this.state = 'CLOSED';
    this.stats = { attempts: 0, failures: 0, successes: 0 };
    this.nextAttempt = 0;
  }

  async fire(...args) {
    if (this.state === 'OPEN') {
      if (Date.now() >= this.nextAttempt) {
        this.state = 'HALF_OPEN';
        this.emit('halfOpen');
      } else {
        const err = new Error('Breaker is open');
        err.code = 'EOPENBREAKER';
        throw err;
      }
    }

    this.stats.attempts += 1;

    try {
      const result = await this._executeWithTimeout(args);
      this._onSuccess();
      return result;
    } catch (err) {
      this._onFailure(err);
      throw err;
    }
  }

  async _executeWithTimeout(args) {
    const timeout = this.options.timeout;
    let timeoutId;
    const timeoutPromise = new Promise((_, reject) => {
      timeoutId = setTimeout(() => {
        const error = new Error('Breaker timeout');
        error.code = 'ETIMEDOUT';
        reject(error);
      }, timeout);
    });

    try {
      return await Promise.race([
        Promise.resolve().then(() => this.action(...args)),
        timeoutPromise,
      ]);
    } finally {
      clearTimeout(timeoutId);
    }
  }

  _onSuccess() {
    this.stats.successes += 1;
    this.stats.failures = Math.max(0, this.stats.failures - 1);
    if (this.state !== 'CLOSED') {
      this.state = 'CLOSED';
      this.emit('close');
    }
  }

  _onFailure(err) {
    this.stats.failures += 1;
    const total = Math.max(this.stats.attempts, 1);
    const failureRate = (this.stats.failures / total) * 100;
    const threshold = this.options.errorThresholdPercentage;
    const volumeThreshold = this.options.volumeThreshold;

    if ((this.stats.attempts >= volumeThreshold && failureRate >= threshold) || err.code === 'ETIMEDOUT') {
      this._trip();
    }
  }

  _trip() {
    if (this.state !== 'OPEN') {
      this.state = 'OPEN';
      this.emit('open');
    }
    this.nextAttempt = Date.now() + this.options.resetTimeout;
  }
}

module.exports = CircuitBreaker;
module.exports.default = CircuitBreaker;
module.exports.CircuitBreaker = CircuitBreaker;
